# Посещаемость

Страница **«Посещаемость»** — центральный рабочий экран системы для фиксации и контроля посещения студентов по занятиям (урокам) в рамках выбранных курсов. Она связывает воедино три доменные сущности проекта:

* **Курс** (Course)
* **Урок / занятие** (Lesson)
* **Студент** (User с ролью Student)
* **Запись посещаемости** (Attendance) = *студент + урок + статус + (опционально) комментарий*

С точки зрения архитектуры это типичный экран “данные + фильтры + таблица + точечное редактирование”, который работает поверх REST API и использует авторизацию по Bearer-токену (JWT) на backend.

---

## 1) Пользовательские сценарии

### 1.1. Администратор

Администратор использует страницу для:

* контроля общей картины по курсам/датам;
* поиска проблем (массовые пропуски, “аномальные” статусы);
* точечной правки отдельных записей (если предусмотрено правами);
* валидации, что данные корректно сформированы (особенно в демо-режиме/после seed).

### 1.2. Преподаватель

Преподаватель использует страницу как “журнал”:

* выбирает курс и диапазон дат;
* фильтрует по конкретному занятию/студенту;
* отмечает/исправляет статусы посещаемости, добавляет комментарии (если это часть функционала).

### 1.3. Студент (если доступ разрешён)

Обычно студенту либо:

* доступна только **просмотр** своих записей,
* либо страница скрыта, а доступ реализован через “Профиль”/“Мои занятия”.

Правило доступа реализуется через RBAC на backend (зависимость текущего пользователя + проверки роли), при этом сам запрос защищён токеном. 

---
## 2)
---

## 3) UI-структура (логика блоков)

### 3.1. Заголовок и краткое назначение

Верх страницы: заголовок “Посещаемость” и короткое описание/подсказка (опционально). Часто рядом находится кнопка обновления/перезагрузки данных, если ты сделал refresh.

### 3.2. Панель фильтров (Toolbar)

Ключевой элемент: фильтры формируют query-параметры к API.

Типовой набор:

1. **Диапазон дат** (RangePicker)

   * задаёт `date_from` / `date_to`
   * ограничивает выборку по датам занятий (Lesson.date)

2. **Курс** (Select)

   * задаёт `course_id`
   * после выбора курса обычно логично “подгружать” связанные сущности (уроки/студентов), чтобы остальные селекты были релевантными

3. **Урок / занятие** (Select, опционально)

   * задаёт `lesson_id`
   * часто зависит от выбранного курса

4. **Студент** (Select + поиск, опционально)

   * задаёт `student_id`
   * часто поддерживает `showSearch`, чтобы находить по ФИО/почте

5. **Статус** (Select / Segmented / Tabs, опционально)

   * задаёт `status` (например: present/absent/late/excused)
   * удобно делать мультивыбор, если надо “показать и absent и late”

6. **Быстрый поиск** (Input, опционально)

   * задаёт `q`
   * ищет по ФИО, названию урока, аудитории и т.п. (зависит от реализации backend)

### 3.3. Таблица результатов (Table)

Таблица — основной рабочий слой.

Типовая структура колонок:

* **Дата занятия**
* **Курс**
* **Урок** (тема/тип/аудитория)
* **Студент** (ФИО)
* **Статус** (Badge/Tag)
* **Комментарий** (если предусмотрен)
* **Действия** (редактировать/сохранить)

Для таблицы критично:

* серверная пагинация (page / page_size),
* отображение общего total,
* сортировки/фильтры (если включены).

В Ant Design сортировки и фильтры работают через обработчик `onChange`, который отдаёт pagination/sorter/filters, и ты можешь преобразовать это в запрос к API.

### 3.4. Пагинация

Если данных много (в твоих демо-объёмах это обязательно), таблица должна:

* запрашивать данные постранично,
* корректно отображать `total`,
* поддерживать смену размера страницы (например 10/20/50/100).

Параметры пагинации в Ant Design стандартизированы (current, pageSize, total и т.д.).

---

## 4) Как данные идут от UI к базе данных

Ниже — “сквозной” поток данных, который должен соответствовать твоему коду по смыслу, даже если названия параметров/функций чуть отличаются.

### 4.1. Первичная загрузка страницы

1. Frontend открывает страницу “Посещаемость”.
2. Параллельно запрашиваются справочники для фильтров:

   * список курсов (для Select “Курс”)
   * при необходимости список студентов (или он подтягивается по курсу)
3. Таблица либо:

   * показывает “пустое состояние” до выбора фильтров,
   * либо грузит дефолтный диапазон (например последние 7/30 дней).

### 4.2. Пользователь выставляет фильтры

Каждое изменение фильтра:

* обновляет локальный state (selectedCourseId, dateRange, selectedStudentId …),
* сбрасывает пагинацию на 1-ю страницу (важно!),
* триггерит загрузку таблицы.

Рекомендуемая стратегия:

* не дергать API на каждый ввод символа,
* применять “по кнопке” или debounce на поиск (если есть).

### 4.3. Запрос к backend (GET)

Frontend формирует запрос примерно такого вида:

```
GET /api/v1/attendance
  ?date_from=2025-10-01
  &date_to=2025-10-31
  &course_id=12
  &lesson_id=55
  &student_id=1031
  &status=absent
  &page=1
  &page_size=50
```

Backend возвращает:

* `items`: список строк для таблицы
* `total`: общее число записей под фильтр

### 4.4. Отрисовка таблицы

Frontend:

* кладёт `items` в dataSource таблицы,
* выставляет pagination.total = total,
* показывает Tag/Badge для статуса,
* отображает загрузку (spinning) на время запроса.

---

## 5) Редактирование посещаемости (если включено)

Если на странице есть “карандаш/редактировать”:

### 5.1. UI-паттерн

Наиболее устойчивые варианты:

* inline-редактирование строки (сложнее),
* модальное окно “Изменить статус” (проще и надёжнее),
* drawer-панель справа (комфортно для длинных комментариев).

### 5.2. PATCH/PUT запрос

После изменения статуса/комментария отправляется запрос:

```
PATCH /api/v1/attendance/{attendance_id}
{
  "status": "late",
  "comment": "Опоздал на 10 минут"
}
```

Backend:

* проверяет права (admin/teacher),
* валидирует допустимость перехода статусов (если правила есть),
* сохраняет.

Frontend:

* либо перезапрашивает текущую страницу таблицы,
* либо делает оптимистичное обновление (update локально) + fallback при ошибке.

---

## 6) Backend-реализация (что там обычно важно)

### 6.1. Авторизация

Все запросы к посещаемости должны требовать токен:

* Frontend отправляет `Authorization: Bearer <token>`
* FastAPI проверяет токен через security dependency (OAuth2/JWT). 

### 6.2. SQL/ORM-слой

Запрос списка посещаемости почти всегда требует join’ов, чтобы таблица сразу показывала “человеческие” поля:

* название курса,
* тему урока,
* ФИО студента,
* дату занятия.

Опасность: N+1 запросы, когда для каждой строки отдельно догружаются lesson/student/course.

Правильная практика в SQLAlchemy — использовать eager loading (например selectinload), чтобы уменьшить число запросов и стабилизировать время ответа на больших объёмах. 

### 6.3. Индексация и уникальность

Для посещаемости критично:

* (lesson_id, student_id) должны быть уникальны, иначе “дубли посещения” ломают аналитику.
* индексы по lesson_id, student_id, (date) ускоряют фильтрацию.

---

## 7) Проверка работоспособности (ручной чек-лист)

1. Зайти под **админом**.
2. Открыть “Посещаемость”.
3. Выбрать диапазон дат, где точно есть занятия.
4. Выбрать курс → убедиться, что таблица обновилась и результаты релевантны.
5. Переключить page/pageSize → убедиться, что запросы идут постранично и total не “скачет”.
6. (Если есть) применить фильтр “Статус = absent” → убедиться, что выдача меняется.
7. (Если есть права) изменить статус записи → убедиться, что после сохранения строка обновилась.
8. Повторить под ролью преподавателя (должно быть доступно) и под студентом (обычно ограничено).