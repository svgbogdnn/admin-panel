# Авторизация и учетные записи (Логин и Регистрация)

Этот раздел описывает, **как именно устроен вход в систему и создание аккаунта**, как фронтенд и бэкенд взаимодействуют вместе о пользователе, токене, правах доступа и как дальше выполняются защищённые запросы (Курсы / Посещаемость / Фидбэк / Экспорт / Профиль).

Скриншоты интерфейса:

* Экран входа: `imgs/Login/Login1.png`
* Ошибка входа (неверные данные): `imgs/Login/Login2.png`
* Экран регистрации: `imgs/Login/Login3.png`, `imgs/Login/Login4.png`
* Успешная регистрация (уведомление): `imgs/Login/Login5.png`
* Экран входа после регистрации: `imgs/Login/Login6.png`
* Профиль (данные/безопасность): `imgs/Profile/Profile1.png`, `imgs/Profile/Profile2.png`, `imgs/Profile/Profile3.png`, `imgs/Profile/Profile4.png`

---

## 1) Роли и модель доступа (RBAC)

Система использует **ролевую модель доступа** (Role-Based Access Control):

* **Администратор**: полный доступ ко всем разделам и операциям.
* **Преподаватель**: доступ к “рабочим” разделам (например, Курсы/Уроки/Посещаемость в рамках логики проекта).
* **Студент**: ограниченный доступ (обычно просмотр/личные данные/свои записи).

Роль хранится на стороне бэкенда в поле пользователя (в базе), а фронтенд **не “придумывает” права**, а только отображает интерфейс и отправляет запросы; окончательное решение всегда принимает бэкенд (через зависимости/проверки в роутерах).

---

## 2) Что такое “логин” в проекте

**Вход** — это процесс получения “пропуска” (access token), который затем прикладывается к каждому защищённому запросу.

Технически это выглядит так:

1. Пользователь вводит email и пароль на странице входа.
   Пример UI: `imgs/Login/Login1.png`

2. Фронтенд отправляет запрос на бэкенд (endpoint логина).

3. Бэкенд:

   * находит пользователя по email;
   * проверяет пароль (сравнивая с хешем пароля, сохранённым в базе);
   * проверяет, что пользователь активен (если предусмотрено);
   * если всё корректно — выдаёт **access token**.

4. Фронтенд сохраняет токен и начинает добавлять его в заголовки дальнейших запросов как **Bearer Token**.

Формат заголовка “Bearer” стандартизирован: `Authorization: Bearer <token>`

---

## 3) Бэкенд: основные auth-endpoints и их назначение

Реализация авторизации сосредоточена в файлах вида:

* `backend/app/api/v1/auth.py` — роуты логина/регистрации/получения текущего пользователя (в зависимости от реализации).
* `backend/app/core/security.py` — генерация/проверка токена, функции работы с паролями, получение текущего пользователя из токена.
* `backend/app/api/v1/users.py` — операции “профиля” (например, `me`, смена пароля и т.п.).

### 3.1 Логин: получение токена

Типовой endpoint:

* `POST /api/v1/login` (или логически эквивалентный путь в вашем роутере)

**Входные данные**: email + password.
**Ответ**: объект с токеном и типом токена (обычно `"bearer"`).

FastAPI-референс (если проект следует OAuth2 Password Flow): используется `OAuth2PasswordBearer` и `OAuth2PasswordRequestForm` ([FastAPI][1])
Примечание: даже если в проекте payload отправляется не как `x-www-form-urlencoded`, а JSON — логика “получили токен → используем Bearer” остаётся той же.

### 3.2 Получение текущего пользователя (“who am I”)

Типовой endpoint:

* `GET /api/v1/me` **или**
* `GET /api/v1/users/me`

Назначение:

* фронтенд после логина (или после перезагрузки страницы) проверяет токен и подтягивает текущего пользователя;
* на основе ответа можно:

  * показать имя/роль/статус,
  * включить/скрыть пункты меню,
  * открыть/закрыть доступ к страницам.

### 3.3 Регистрация

Скриншоты регистрации: `imgs/Login/Login3.png`, `imgs/Login/Login4.png`

Важный смысл проекта (по UI): **создание учётной записи администратора**. Это практично для демо: преподаватель/проверяющий может создать admin-аккаунт и дальше работать с системой.

Типовой endpoint:

* `POST /api/v1/register`

Что происходит на бэкенде:

* валидация входных данных;
* проверка уникальности email;
* хеширование пароля;
* создание пользователя с нужной ролью/флагами.

Успешная регистрация отображается уведомлением: `imgs/Login/Login5.png`, после чего предлагается перейти к входу.

---

## 4) Бэкенд: как токен работает внутри FastAPI

Если проект использует стандартный подход FastAPI Security:

1. В `backend/app/core/security.py` описывается схема получения токена из заголовка:

* `OAuth2PasswordBearer(tokenUrl=...)` ([FastAPI][1])

2. Далее реализуется зависимость наподобие `get_current_user`:

* берёт токен из `Authorization: Bearer ...`;
* декодирует токен;
* достаёт `sub` (subject) или `user_id` (в зависимости от формата токена);
* получает пользователя из БД;
* возвращает пользователя в роут.

3. Для контроля прав доступа добавляются зависимости уровня “требуется админ” / “требуется преподаватель или админ” и т.п. Они проверяют `user.role` и/или служебные флаги.

Это и есть точка, где проект гарантирует: **нельзя “подделать роль” на фронтенде** — доступ решается сервером.

---

## 5) Фронтенд: логин/регистрация, хранение токена, защищённые страницы

Фронтенд-часть логически состоит из:

* Страниц:

  * Login (вход): `imgs/Login/Login1.png`, `imgs/Login/Login2.png`
  * Register (регистрация): `imgs/Login/Login3.png`, `imgs/Login/Login4.png`
  * Profile: `imgs/Profile/Profile1.png` … `imgs/Profile/Profile4.png`

* API-слоя (обёртки над запросами):

  * методы `login()`, `register()`, `getCurrentUser()` и т.п.
  * общий HTTP-клиент (часто axios/fetch) с базовым URL и заголовками.

### 5.1 Что делает LoginPage

1. Собирает данные формы (email, password).
2. Вызывает `login()` из API-слоя.
3. Если успех:

   * сохраняет токен (часто `localStorage`/`sessionStorage`),
   * перекидывает на защищённую часть приложения.
4. Если ошибка (401/403/422):

   * показывает человекочитаемое сообщение (пример: `imgs/Login/Login2.png`).

### 5.2 Что делает RegisterPage

1. Собирает ФИО, email, пароль, подтверждение, согласие.
2. Делает `register()` на бэкенд.
3. При успехе:

   * показывает уведомление,
   * предлагает перейти на Login (пример: `imgs/Login/Login5.png`).

### 5.3 Как прикладывается токен к запросам

После входа каждый запрос к защищённым endpoints должен идти с:

* `Authorization: Bearer <access_token>`

Обычно это делается централизованно:

* либо через interceptor (axios),
* либо через общую функцию fetch(), которая добавляет header автоматически.

### 5.4 Route Guard (защита роутов на фронтенде)

Фронтенд обычно защищает страницы так:

* Если токена нет → редирект на `/login`.
* Если токен есть → пробует `GET /api/v1/me` (или `/users/me`):

  * успех → можно рендерить приложение,
  * ошибка → токен невалиден/просрочен → очистка токена → редирект на `/login`.

---

## 6) Профиль и смена пароля

Профиль показывает данные пользователя и даёт изменить часть полей:

* Пример “Данные”: `imgs/Profile/Profile1.png`, `imgs/Profile/Profile2.png`
* Вкладка “Безопасность” / смена пароля: `imgs/Profile/Profile3.png`

Логика смены пароля обычно такая:

1. Пользователь вводит текущий пароль и новый пароль.
2. Запрос на бэкенд идёт **с Bearer-токеном**, чтобы сервер точно знал, кто именно меняет пароль.
3. Бэкенд проверяет текущий пароль и сохраняет новый (в виде хеша).

---

## 7) Безопасность.

### 7.1 Где хранить токен

Если токен хранится в `localStorage`, это удобно для демо, но важно понимать риск: данные web storage доступны JavaScript-коду страницы и могут быть украдены при XSS. OWASP прямо указывает, что Web Storage не защищает от доступа через JS, и акцентирует риски при XSS-сценариях ([OWASP Cheat Sheet Series][2])

Для production-подхода часто рассматривают:

* HttpOnly Secure cookies (токен недоступен JS),
* короткоживущий access token + refresh token,
* строгую CSP и XSS-hardening.

### 7.2 Сервер — единственный источник прав

Даже если фронтенд “прячет” кнопки/пункты меню, реальная защита — это:

* проверки роли на сервере (dependencies),
* запрет опасных операций не-админу на уровне API.

---

## 8) Типовые проблемы и быстрая диагностика

1. **Не входит при “правильных” данных**

* Проверить, что запрос логина идёт на правильный baseURL (`/api/v1/...`).
* Проверить, что бэкенд реально запущен и доступен.
* Посмотреть Network → ответ сервера:

  * 401 → неверные данные,
  * 422 → формат запроса не совпал с тем, что ждёт бэкенд,
  * 500 → ошибка на сервере (лог бэкенда покажет причину).

2. **После регистрации не удаётся войти**

* Убедиться, что регистрация создаёт пользователя в БД (а не только показывает “успех” на фронте).
* Убедиться, что пароль хешируется/проверяется одной и той же функцией (консистентность hashing).
* Убедиться, что пользователь создаётся активным.

3. **Токен есть, но /me возвращает 401**

* Токен не прикладывается (нет `Authorization` header).
* Неправильный префикс: должно быть `Bearer`, а не `Token`/`JWT`.
* Токен просрочен или подписан другим SECRET_KEY (например, при смене env).