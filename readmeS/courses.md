# Курсы

Раздел **Курсы** — это центральный CRUD-модуль системы: он задаёт “контейнер” для учебной структуры, к которому дальше привязываются **уроки**, а через уроки — **посещаемость** и **фидбек**. Практически всё, что дальше делает система (аналитика, экспорт, отчёты), в итоге группируется вокруг курса.

---

## 1) Пользовательская логика раздела

### Что пользователь должен уметь на странице “Курсы”

1. **Просмотреть список курсов** (таблица/список).
2. **Быстро найти курс** по названию/части названия (поиск).
3. **Отфильтровать курсы** по статусу (активный/неактивный/все).
4. **Оценить ситуацию “по верхам”** через быстрые метрики (всего курсов, активные, скоро заканчиваются и т.д.).
5. **Создать курс**.
6. **Открыть карточку/детали курса**.
7. **Отредактировать курс**.
8. (Опционально) **Удалить курс** — если в проекте это включено и разрешено правами.

Скриншоты раздела (как выглядят ключевые состояния):

* Список/таблица курсов: `imgs/Courses/Courses1.png`, `imgs/Courses/Courses4.png`, `imgs/Courses/Courses6.png`
* Создание курса: `imgs/Courses/Courses2.png`
* Детали курса: `imgs/Courses/Courses3.png`

---

## 2) Модель данных “Курс” (что именно хранится)

Типовая сущность курса в вашем проекте (судя по UI и связям модулей) включает:

* `id` — идентификатор
* `name` / `title` — название курса (в UI это главный текст строки)
* `description` — описание (в таблице часто показывается как обрезанный текст)
* `start_date` — дата начала
* `end_date` — дата окончания
* `is_active` — активность (в UI как “Активный/Неактивный”)
* `teacher_id` — привязка к преподавателю (в UI у вас фигурирует как поле ID, см. `imgs/Courses/Courses2.png`)

### Связи

* **Курс → Уроки**: один курс содержит много уроков (это базовая связь, от которой зависит посещаемость/фидбек).
* **Урок → Посещаемость**: посещаемость пишется на уровень урока.
* **Урок → Фидбек**: фидбек тоже на уровне урока.

На уровне ORM это почти всегда делается через `relationship()` в SQLAlchemy и настройки загрузки связей (lazy/eager). Если вы запрашиваете курсы и затем в цикле дёргаете связанные уроки, можно поймать N+1. В SQLAlchemy это решается стратегиями загрузки связей (например, `selectinload`, `joinedload`) — это стандартная механика ORM. ([SQLAlchemy][1])

---

## 3) Backend: какие операции должна обеспечивать API-часть

Backend-модуль курсов находится по пути:

* `backend/app/api/v1/courses.py`

И опирается на:

* `backend/app/models/...` (ORM-модели)
* `backend/app/schemas/...` (Pydantic-схемы)
* `backend/app/core/...` (настройки, БД, безопасность)

### Минимальный REST-набор (ожидаемое поведение)

1. **Получить список курсов**

   * `GET /api/v1/courses`
   * Параметры (типовая практика):

     * `search` или `q` — строка поиска (название/описание)
     * `is_active` — фильтр статуса
     * `skip`, `limit` — пагинация (или `page`, `page_size`)
   * Возвращает массив курсов и (если реализовано) метаданные пагинации.

2. **Получить один курс**

   * `GET /api/v1/courses/{course_id}`

3. **Создать курс**

   * `POST /api/v1/courses`
   * Тело: `name/title`, даты, `description`, `teacher_id`, `is_active`

4. **Обновить курс**

   * `PUT` или `PATCH /api/v1/courses/{course_id}`

5. **Удалить курс** (если включено)

   * `DELETE /api/v1/courses/{course_id}`

### Доступ и авторизация

Раздел “Курсы” почти всегда закрыт авторизацией (требуется access token). На практике это означает:

* frontend сначала получает токен через логин,
* затем отправляет запросы в курсы **с заголовком** `Authorization: Bearer <token>`.

Если у вас backend реализует OAuth2 password flow, важно помнить: по спецификации поля логина передаются **form-data** и называются именно `username` и `password` (даже если вы логинитесь email’ом, email обычно кладут в `username`). ([FastAPI][2])

---

## 4) Frontend: как устроена страница “Курсы”

### 4.1 Роутинг

Обычно у таких проектов есть:

* `/courses` — список
* `/courses/:id` — детали курса (см. `imgs/Courses/Courses3.png`)
* иногда `/courses/new` — отдельная страница создания, либо создание делается модалкой/формой на месте (см. `imgs/Courses/Courses2.png`)

### 4.2 Почему чаще всего используется таблица (и что важно учесть)

Ваш UI визуально соответствует типичному паттерну Ant Design Table: колонки, действия, сортировка/фильтрация, пагинация (см. `imgs/Courses/Courses4.png`, `imgs/Courses/Courses6.png`).

Ключевые моменты Ant Design Table, которые прямо влияют на стабильность:

* у каждой строки должен быть уникальный ключ (`rowKey`), иначе будут предупреждения и потенциально “прыгающее” поведение строк;
* фильтрация обычно сбрасывает пагинацию на первую страницу (это ожидаемая логика);
* пагинацию и фильтры можно вести как локально (по уже загруженным данным), так и “удалённо” (каждое изменение фильтра перезапрашивает backend). ([Ant Design][3])

### 4.3 Данные, которые рисуются в списке

По вашим скринам список курсов отдаёт в UI минимум:

* название
* даты начала/окончания
* статус “Активный/Неактивный”
* описание (обрезка)
* действия (кнопки)

Типовые действия (по вашим экранам):

* “Подробнее” (детали курса)
* “Редактировать”
* “Добавить курс”

Ссылки на примеры:

* общий вид списка: `imgs/Courses/Courses4.png`
* поиск + статус-фильтр + “скоро закончится”: `imgs/Courses/Courses6.png`

---

## 5) Логика “скоро закончится” (как это обычно считается)

На `imgs/Courses/Courses6.png` у вас виден бейдж вида “≤ 14 дней до конца”. Практически всегда это считается на фронте так:

1. Берём `end_date`.
2. Считаем разницу `end_date - today` в днях.
3. Если разница `>= 0` и `<= 14`, показываем бейдж “скоро завершится”.

Важные детали, чтобы не было багов:

* приводить дату к полуночи (иначе из-за часов/таймзоны можно получить “13 дней” вместо “14”);
* корректно обрабатывать `end_date = null` (если такие курсы разрешены);
* не показывать “скоро завершится” для неактивных курсов, если это не задумано UX-ом.

---

## 6) Создание и редактирование курса

### 6.1 Создание (форма)

По `imgs/Courses/Courses2.png` видно, что форма включает:

* название
* описание
* дата начала
* дата окончания
* активность
* ID учителя

Что важно на уровне UX/валидации:

* `start_date <= end_date`
* обязательность `name/title`
* `teacher_id` должен указывать на существующего пользователя-преподавателя (если в проекте есть роли)

### 6.2 Редактирование

Сценарий редактирования обычно повторяет создание, но:

* поля предзаполнены,
* отправляется `PUT/PATCH`,
* после успеха:

  * обновляется строка в таблице,
  * показывается toast (у вас это видно на `imgs/Courses/Courses5.png`).