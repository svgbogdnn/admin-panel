### Авторизация в проекте (как реализовано сейчас)

**1) Регистрация пользователя**

* На бэкенде есть endpoint `POST /api/v1/register`, который создаёт пользователя по `email / password / full_name / is_active`. Пароль сохраняется **в хешированном виде**.
* В текущей реализации при регистрации роль выставляется **`student`** (то есть регистрация не создаёт администратора).
* На фронте есть функция `registerUser()` которая отправляет эти данные на `/register`.

**2) Логин и получение токена**

* На бэкенде `POST /api/v1/login`: проверяет email/пароль, проверяет `is_active`, и возвращает **JWT access token** формата `{access_token, token_type: "bearer"}`.
* На фронте `login()` кладёт `access_token` в `localStorage`.

**3) Как запросы становятся “авторизованными”**

* На фронтенде axios-интерсептор автоматически добавляет заголовок `Authorization: Bearer <token>` ко всем запросам, если токен есть в `localStorage`.
* На бэкенде `get_current_user()` вытаскивает токен через `OAuth2PasswordBearer`, декодирует JWT, берёт `sub` (user_id), загружает пользователя из БД и проверяет, что он активен. 

**4) “Кто я?” и профиль**

* Есть endpoint `GET /api/v1/me` (в auth router) — вернуть текущего пользователя по токену. 
* И есть отдельный “профильный” набор: `GET /api/v1/users/me`, `PATCH /api/v1/users/me`, `POST /api/v1/users/me/change-password`. Это уже “профиль” (редактирование полей + смена пароля) и он завязан на `get_current_user`.

**5) Роли и доступы (RBAC)**

* В `security.py` определены роли `admin/teacher/student` и зависимости-декораторы `require_admin`, `require_admin_or_teacher` — ими защищены админские/преподавательские endpoints (например, список пользователей).
